/*
  696. 计数二进制子串

  给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。
  重复出现的子串要计算它们出现的次数。

  示例 1 :
    输入: "00110011"
    输出: 6
    解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。

    请注意，一些重复出现的子串要计算它们出现的次数。
    另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。

  示例 2 :
    输入: "10101"
    输出: 4
    解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。

  注意：
    s.length 在1到50,000之间。
    s 只包含“0”或“1”字符。
*/

/*
  解题思路：
    0、参数判断：只能输入内容为01的字符串
    1、外层循环遍历字符串 00110011 => 0
    2、内层循环遍历子串 ex: 00110011 => 0110011
      2.1、把逻辑放到外部处理，使内部展示简洁
      2.2、创建一个函数，把当前字符 与 子串作为参数传递进去，
        最终返回匹配结果，如果存在结果，就把结果保存在数组中
      2.3、根据判断条件 => 01(连续) => 指定边界
      2.4、边界条件：开始项 === 结束项
        便捷条件：如果 当前字符 与 子串第一个字符不相等，即本次匹配成功，返回字符为：当前字符 + 子串第一个字符
      2.5、获取开始项，默认为当前字符
        循环遍历子串，查找与当前字符相等的字符，把找到的字符拼接到开始项中，
          直到找到一个与当前字符不相等的字符，开始项获取完毕；

        边界条件：如果开始项的长度 > 剩余字符长度，本次当前字符匹配失败，即不存在该字符
      2.6、获取结束项，默认为空
        开始项获取结束，即接着获取结束项；查找与当前字符不相等的字符，把找到的字符拼接到结束项中，
          直到找到一个与当前字符相等的字符，结束项获取完毕；

        边界条件：开始项的长度 === 结束项长度，本次当前字符匹配成功，遍历结束，即返回存在字符：开始项 + 结束项

*/

function matchSubStr(item, subStr) {
  // 一位连续匹配：如果当前项与子串的第一位不相等，代表匹配成功，则直接把结果返回
  if (item !== subStr[0]) { return item + subStr[0]; }

  // 多位匹配
  // 初始开始项为当前项
  let startStr = item;
  // 结束项为空
  let endStr = "";
  // 是否开启开始项匹配，因为开始项一旦匹配完毕之后就要开始匹配结束项
  let isStart = true;

  // 开始匹配
  for (let i = 0, len = subStr.length; i < len; i++) {
    let currSubStr = subStr[i];

    // 选取开始项操作
    if (isStart) {
      // 当前项 与 子串当前项 一致，则把当前项加到开始项中
      if (item === currSubStr) {
        startStr += currSubStr;

        // 如果开始项的长度比结束项的长度大，则代表匹配失败，直接返回未找到
        if (startStr.length > (len - 1 - i)) { return false; }

        continue;
      }

      // 开始项匹配结束
      isStart = false;
      // 把当前项条件到结束项中
      endStr += currSubStr;

      continue;
    }

    // 选取结束项操作

    // 如果当前项与当前子项一致，则代表匹配失败，直接返回未找到
    if (item === currSubStr) { return false; }

    // 如果当前项与开始项不一致，即把当前项加到结束项中
    endStr += currSubStr;

    // 如果开始项等于结束项，则证明匹配成功，直接把结果返回
    if (startStr.length === endStr.length) { return startStr + endStr; }
  }

  // 其实在循环内已经匹配完毕，这里无需再返回，当加一层保险吧
  return false;
}

export default binaryStr => {
  if (/[^01]/g.test(binaryStr)) { throw TypeError('请输入一个二进制字符串，谢谢合作!') }

  let result = [];
  // 最后一项无需再匹配，因为结束没有匹配项了
  for (let i = 0, endIndex = binaryStr.length-1; i < endIndex; i++) {
    let subStr = matchSubStr(binaryStr[i], binaryStr.slice(i+1));
    subStr && result.push(subStr);
  }

  return result.length;
}